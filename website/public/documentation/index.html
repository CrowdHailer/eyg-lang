<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      href="https://unpkg.com/tailwindcss@2.2.11/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/layout.css" />
    <link rel="stylesheet" href="/neo.css" />
    <script src="/easel.js" async defer></script>
    <title>Documentation - Eyg</title>
  </head><body ><div  class="vstack wrap"><header  class="yellow-gradient drop w-full"><div class="hstack max-w-3xl mx-auto">
          <div class="expand leading-relaxed">
            <div class="text-pink-4 border-l-8 border-white pl-2 -ml-2">
              There is no <strong class="font-bold">syntax</strong> ...
            </div>
            <ul class="underline text-black pl-2">
              <li><a href="/">Home</a></li>
              <li><a href="/documentation">Documentation</a></li>
            </ul>
          </div>
          <div class="border-2 border-black bg-purple-3 my-10 rounded-xl neo-shadow -mr-20">
            <div class="ml-5 mr-24">
              <h3 class="font-bold text-white">Eat Your Greens</h3>
              <h1 class="text-2xl font-bold">EYG</h1>
            </div>
          </div>
        </div><div class="max-w-3xl mx-auto px-4 my-4 text-xl hstack wrap">
            <h1>TODO title</h1>
            <span class="expand"></span>
          </div></header><div  class="max-w-3xl mx-auto px-4 my-4 text-xl hstack wrap"><h1>TODO title</h1></div><div  class="vstack bg-gray-50 wrap"><div  class="loose doc"><h1  class="text-2xl">Language</h1><a  href="/documentation/effects" class="text-blue-500 underline">Effects</a><h2  class="text-lg max-w-2xl mx-auto">Introduction</h2><p  class="max-w-2xl mx-auto">This language is an experiment in making a highly portable functional language. The syntax shown below only illustrates the features of the language, it is only one of many possible projections to view a program. Creating programs is not done by editing text files instead a structured editor is needed.</p><p  class="max-w-2xl mx-auto">The language has both a compiler and interpreter, either or even both can be used in one program.
Anonymous functions can be captured, serialised and sent to other computers. 
For example a client and server app can be written as one function.</p><pre  class="bg-gray-200">_ -> {
  let html = vacant
  request -> client -> {
    let method = request.method
    let handle_click = perform Alert(method)
    html.button("click")(handle_click)
  }
}</pre><p  class="max-w-2xl mx-auto">A fully exhaustive type checker exists for the language. i.e. if the checks pass it is guaranteed not to crash.
This can be optionally run, it's not worth type checking a build script you get the same error anyway.
It's possible to type check a single function.</p><p  class="max-w-2xl mx-auto">Because the type system is complete and structural no type ever needs to be declared up front and no annotation is required, in fact annotation is not supported in the language.
This choice is to make programmers never need to think about types.
Type annotations are possible in the editor but they are only a debug tool and not committed to the source.</p><p  class="max-w-2xl mx-auto">The type system contains extensible records and unions as well as an algebraic effect system. 
These three components are all built on row types, using the same approach for each keeps the implementation simple.
</p><p  class="max-w-2xl mx-auto">All of the goals of the language are achieved by having the Abstract Syntax Tree (AST) of the language be the public interface and keeping that interface as small as possible.
There are currently only 19 different node types that make up the AST.</p><pre  class="bg-gray-200">_ -> {
  let string = vacant
  let welcome = person -> {
    let message = string.append("Hello ")(person)
    perform Log(message)
  }
  welcome("Alan")
}</pre><h2  class="text-lg max-w-2xl mx-auto">literal</h2><pre  class="bg-gray-200">_ -> {
  let i = 100
  let s = "hello"
  let list = [1, 2]
  {}
}</pre><h2  class="text-lg max-w-2xl mx-auto">functions</h2><p  class="max-w-2xl mx-auto">All functions are anonymous.
Functions are first class an can be returned by other functions.
There is no support for multi-argument functions, to accept multiple arguments a function must return a function, and is therefore automatically curried</p><pre  class="bg-gray-200">_ -> {
  let single = x -> [x]
  let _ = single(10)
  let double = x -> y -> [x, y]
  let _ = double(1)(2)
  let start_with_one = double(1)
  start_with_one(7)
}</pre><h2  class="text-lg max-w-2xl mx-auto">Let bindings</h2><p  class="max-w-2xl mx-auto">A value can be given a name using let. 
Names can be reused by later let bindings, but the values contained are immutable, meaning the values themselves cannot be changed.</p><pre  class="bg-gray-200">_ -> {
  let a = 1
  let b = a
  let a = 2
  b
}</pre><h2  class="text-lg max-w-2xl mx-auto">Records</h2><p  class="max-w-2xl mx-auto">Records are used to store multiple values with a name. 
Typing is structural and so there is no need to define types a head of time.
Because typing is structural any record with the fields required by a function can be passed to that function</p><pre  class="bg-gray-200">a -> {
  let alice = {name: "Alice", age: 10}
  let name = alice.name
  let alice = {age: 11, ..alice}
  let age = alice.age
  let get_name = user -> user.name
  let _ = get_name(alice)
  let bob = {name: "Bob"}
  let _ = get_name(bob)
  {}
}</pre><h2  class="text-lg max-w-2xl mx-auto">Unions</h2><p  class="max-w-2xl mx-auto">Unions are tagged unions, they are extensible. Case statements are first class i.e. it is possible to compose them.</p><pre  class="bg-gray-200">_ -> {
  let ok = Ok(5)
  let unwrap = fallback -> match {
    Ok value -> value
    Error _ -> fallback
  }
  let _ = unwrap(0)(ok)
  {}
}</pre><p  class="max-w-2xl mx-auto">matches can be open</p><pre  class="bg-gray-200">_ -> {
  let multiline = match {
    Let _ -> True({})
    _other -> False({})
  }
  {}
}</pre><p  class="max-w-2xl mx-auto">matches can be composed
</p><pre  class="bg-gray-200">_ -> {
  let pets = match {
    Cat _ -> "felix"
    Dog _ -> "fido"
  }
  let animals = match {
    Platypus _ -> {
      let _ = perform Log("special pet")
      "Alan"
    }
    pets
  }
  {}
}</pre></div><span  class="expand"></span><footer  class="bg-gray-800 cover">language</footer></div></div></body>