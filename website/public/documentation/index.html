<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      href="https://unpkg.com/tailwindcss@2.2.11/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/layout.css" />
    <link rel="stylesheet" href="/neo.css" />
    <script src="/easel.js" async defer></script>
    <title>Documentation - Eyg</title>
  </head><body ><div  class="vstack wrap"><header  class="yellow-gradient drop w-full"><div class="hstack max-w-3xl mx-auto">
          <div class="expand leading-relaxed">
            <div class="text-pink-4 border-l-8 border-white pl-2 -ml-2">
              There is no <strong class="font-bold">syntax</strong> ...
            </div>
            <ul class="underline text-black pl-2">
              <li><a href="/">Home</a></li>
              <li><a href="/documentation">Documentation</a></li>
            </ul>
          </div>
          <div class="border-2 border-black bg-purple-3 my-10 rounded-xl neo-shadow -mr-20">
            <div class="ml-5 mr-24">
              <h3 class="font-bold text-white">Eat Your Greens</h3>
              <h1 class="text-2xl font-bold">EYG</h1>
            </div>
          </div>
        </div><div  class="max-w-3xl mx-auto px-4 my-4 text-xl hstack wrap"><h1 ></h1><span  class="expand"></span></div></header><div  class="max-w-3xl mx-auto px-4 my-4 text-xl hstack wrap"><h1>TODO title</h1></div><div  class="expand w-full blue-gradient drop"><h1  class="text-2xl">Language</h1><a  href="/documentation/effects" class="text-blue-500 underline">Effects</a><div  class="max-w-3xl w-full mx-auto"><h2  class="mx-4">Introduction</h2></div><p  class="max-w-3xl w-full mx-auto px-4 text-lg">This language is an experiment in making a highly portable functional language. The syntax shown below only illustrates the features of the language, it is only one of many possible projections to view a program. Creating programs is not done by editing text files instead a structured editor is needed.</p><p  class="max-w-3xl w-full mx-auto px-4 text-lg">The language has both a compiler and interpreter, either or even both can be used in one program.
Anonymous functions can be captured, serialised and sent to other computers. 
For example a client and server app can be written as one function.</p><div  class="max-w-3xl w-full mx-auto"><div  class="wrap bg-white neo-shadow border-black border-2 mb-2 rounded-xl overflow-hidden"><pre  class="overflow-auto outline-none w-full my-1 mx-4">_ -> {
  let html = vacant
  request -> client -> {
    let method = request.method
    let handle_click = perform Alert(method)
    html.button("click")(handle_click)
  }
}</pre><div  class="bg-purple-1 px-4 font-mono font-bold">:</div></div></div><p  class="max-w-3xl w-full mx-auto px-4 text-lg">A fully exhaustive type checker exists for the language. i.e. if the checks pass it is guaranteed not to crash.
This can be optionally run, it's not worth type checking a build script you get the same error anyway.
It's possible to type check a single function.</p><p  class="max-w-3xl w-full mx-auto px-4 text-lg">Because the type system is complete and structural no type ever needs to be declared up front and no annotation is required, in fact annotation is not supported in the language.
This choice is to make programmers never need to think about types.
Type annotations are possible in the editor but they are only a debug tool and not committed to the source.</p><p  class="max-w-3xl w-full mx-auto px-4 text-lg">The type system contains extensible records and unions as well as an algebraic effect system. 
These three components are all built on row types, using the same approach for each keeps the implementation simple.
</p><p  class="max-w-3xl w-full mx-auto px-4 text-lg">All of the goals of the language are achieved by having the Abstract Syntax Tree (AST) of the language be the public interface and keeping that interface as small as possible.
There are currently only 19 different node types that make up the AST.</p><div  class="max-w-3xl w-full mx-auto"><div  class="wrap bg-white neo-shadow border-black border-2 mb-2 rounded-xl overflow-hidden"><pre  class="overflow-auto outline-none w-full my-1 mx-4">_ -> {
  let string = vacant
  let welcome = person -> {
    let message = string.append("Hello ")(person)
    perform Log(message)
  }
  welcome("Alan")
}</pre><div  class="bg-purple-1 px-4 font-mono font-bold">:</div></div></div><div  class="max-w-3xl w-full mx-auto"><h2  class="mx-4">literal</h2></div><div  class="max-w-3xl w-full mx-auto"><div  class="wrap bg-white neo-shadow border-black border-2 mb-2 rounded-xl overflow-hidden"><pre  class="overflow-auto outline-none w-full my-1 mx-4">_ -> {
  let i = 100
  let s = "hello"
  let list = [1, 2]
  {}
}</pre><div  class="bg-purple-1 px-4 font-mono font-bold">:</div></div></div><div  class="max-w-3xl w-full mx-auto"><h2  class="mx-4">functions</h2></div><p  class="max-w-3xl w-full mx-auto px-4 text-lg">All functions are anonymous.
Functions are first class an can be returned by other functions.
There is no support for multi-argument functions, to accept multiple arguments a function must return a function, and is therefore automatically curried</p><div  class="max-w-3xl w-full mx-auto"><div  class="wrap bg-white neo-shadow border-black border-2 mb-2 rounded-xl overflow-hidden"><pre  class="overflow-auto outline-none w-full my-1 mx-4">_ -> {
  let single = x -> [x]
  let _ = single(10)
  let double = x -> y -> [x, y]
  let _ = double(1)(2)
  let start_with_one = double(1)
  start_with_one(7)
}</pre><div  class="bg-purple-1 px-4 font-mono font-bold">:</div></div></div><div  class="max-w-3xl w-full mx-auto"><h2  class="mx-4">Let bindings</h2></div><p  class="max-w-3xl w-full mx-auto px-4 text-lg">A value can be given a name using let. 
Names can be reused by later let bindings, but the values contained are immutable, meaning the values themselves cannot be changed.</p><div  class="max-w-3xl w-full mx-auto"><div  class="wrap bg-white neo-shadow border-black border-2 mb-2 rounded-xl overflow-hidden"><pre  class="overflow-auto outline-none w-full my-1 mx-4">_ -> {
  let a = 1
  let b = a
  let a = 2
  b
}</pre><div  class="bg-purple-1 px-4 font-mono font-bold">:</div></div></div><div  class="max-w-3xl w-full mx-auto"><h2  class="mx-4">Records</h2></div><p  class="max-w-3xl w-full mx-auto px-4 text-lg">Records are used to store multiple values with a name. 
Typing is structural and so there is no need to define types a head of time.
Because typing is structural any record with the fields required by a function can be passed to that function</p><div  class="max-w-3xl w-full mx-auto"><div  class="wrap bg-white neo-shadow border-black border-2 mb-2 rounded-xl overflow-hidden"><pre  class="overflow-auto outline-none w-full my-1 mx-4">a -> {
  let alice = {name: "Alice", age: 10}
  let name = alice.name
  let alice = {age: 11, ..alice}
  let age = alice.age
  let get_name = user -> user.name
  let _ = get_name(alice)
  let bob = {name: "Bob"}
  let _ = get_name(bob)
  {}
}</pre><div  class="bg-purple-1 px-4 font-mono font-bold">:</div></div></div><div  class="max-w-3xl w-full mx-auto"><h2  class="mx-4">Unions</h2></div><p  class="max-w-3xl w-full mx-auto px-4 text-lg">Unions are tagged unions, they are extensible. Case statements are first class i.e. it is possible to compose them.</p><div  class="max-w-3xl w-full mx-auto"><div  class="wrap bg-white neo-shadow border-black border-2 mb-2 rounded-xl overflow-hidden"><pre  class="overflow-auto outline-none w-full my-1 mx-4">_ -> {
  let ok = Ok(5)
  let unwrap = fallback -> match {
    Ok value -> value
    Error _ -> fallback
  }
  let _ = unwrap(0)(ok)
  {}
}</pre><div  class="bg-purple-1 px-4 font-mono font-bold">:</div></div></div><p  class="max-w-3xl w-full mx-auto px-4 text-lg">matches can be open</p><div  class="max-w-3xl w-full mx-auto"><div  class="wrap bg-white neo-shadow border-black border-2 mb-2 rounded-xl overflow-hidden"><pre  class="overflow-auto outline-none w-full my-1 mx-4">_ -> {
  let multiline = match {
    Let _ -> True({})
    _other -> False({})
  }
  {}
}</pre><div  class="bg-purple-1 px-4 font-mono font-bold">:</div></div></div><p  class="max-w-3xl w-full mx-auto px-4 text-lg">matches can be composed
</p><div  class="max-w-3xl w-full mx-auto"><div  class="wrap bg-white neo-shadow border-black border-2 mb-2 rounded-xl overflow-hidden"><pre  class="overflow-auto outline-none w-full my-1 mx-4">_ -> {
  let pets = match {
    Cat _ -> "felix"
    Dog _ -> "fido"
  }
  let animals = match {
    Platypus _ -> {
      let _ = perform Log("special pet")
      "Alan"
    }
    pets
  }
  {}
}</pre><div  class="bg-purple-1 px-4 font-mono font-bold">:</div></div></div></div></div></body>